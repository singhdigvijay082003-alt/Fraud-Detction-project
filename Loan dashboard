CREATE SCHEMA IF NOT EXISTS loan_mart;

SET search_path = loan_mart;

CREATE TABLE IF NOT EXISTS staging_loans (
    raw_id            BIGSERIAL,
    loan_id           TEXT,
    borrower_id       TEXT,
    disbursement_date DATE,
    origination_date  DATE,
    loan_amount       NUMERIC(14,2),
    outstanding_amount NUMERIC(14,2),
    term_months       INT,
    product           TEXT,
    loan_grade        TEXT,
    region_code       TEXT,
    state             TEXT,
    city              TEXT,
    borrower_age      INT,
    borrower_gender   TEXT,
    borrower_income   NUMERIC(14,2),
    status            TEXT,
    delinquency_days  INT,
    charge_off_flag   INT,
    default_date      DATE,
    created_at        TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS dim_time (
    time_id        DATE PRIMARY KEY,
    year           INT NOT NULL,
    quarter        INT NOT NULL,
    month          INT NOT NULL,
    month_name     TEXT,
    day_of_week    INT
);

CREATE TABLE IF NOT EXISTS dim_region (
    region_id      TEXT PRIMARY KEY,
    region_name    TEXT,
    state          TEXT,
    city           TEXT
);

CREATE TABLE IF NOT EXISTS dim_borrower (
    borrower_id    TEXT PRIMARY KEY,
    age            INT,
    gender         TEXT,
    income         NUMERIC(14,2),
    income_bucket  TEXT,
    employment_tenure INT,
    created_at     TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS dim_loan_grade (
    grade_id       TEXT PRIMARY KEY,
    grade_desc     TEXT
);

INSERT INTO dim_time (time_id, year, quarter, month, month_name, day_of_week)
SELECT d::date, EXTRACT(YEAR FROM d)::int, EXTRACT(QUARTER FROM d)::int,
       EXTRACT(MONTH FROM d)::int, to_char(d, 'Mon'), EXTRACT(DOW FROM d)::int
FROM generate_series('2010-01-01'::date, '2035-12-31'::date, '1 day') AS g(d)
ON CONFLICT (time_id) DO NOTHING;

CREATE TABLE IF NOT EXISTS fact_loan_performance (
    loan_id            TEXT NOT NULL,
    borrower_id        TEXT NOT NULL,
    region_id          TEXT,
    time_id            DATE,
    disbursement_date  DATE,
    origination_date   DATE,
    loan_amount        NUMERIC(14,2),
    outstanding_amount NUMERIC(14,2),
    term_months        INT,
    product            TEXT,
    grade_id           TEXT,
    status             TEXT,
    delinquency_days   INT,
    charge_off_flag    INT,
    default_date       DATE,
    created_at         TIMESTAMP DEFAULT now()
) PARTITION BY RANGE (origination_date);

CREATE TABLE IF NOT EXISTS fact_loan_performance_2015 PARTITION OF fact_loan_performance
    FOR VALUES FROM ('2015-01-01') TO ('2016-01-01');
CREATE TABLE IF NOT EXISTS fact_loan_performance_2016 PARTITION OF fact_loan_performance
    FOR VALUES FROM ('2016-01-01') TO ('2017-01-01');
CREATE TABLE IF NOT EXISTS fact_loan_performance_2017 PARTITION OF fact_loan_performance
    FOR VALUES FROM ('2017-01-01') TO ('2018-01-01');
CREATE TABLE IF NOT EXISTS fact_loan_performance_2018 PARTITION OF fact_loan_performance
    FOR VALUES FROM ('2018-01-01') TO ('2019-01-01');
CREATE TABLE IF NOT EXISTS fact_loan_performance_2019 PARTITION OF fact_loan_performance
    FOR VALUES FROM ('2019-01-01') TO ('2020-01-01');
CREATE TABLE IF NOT EXISTS fact_loan_performance_future PARTITION OF fact_loan_performance
    FOR VALUES FROM ('2030-01-01') TO ('9999-01-01');

INSERT INTO dim_region(region_id, region_name, state, city)
SELECT DISTINCT region_code, region_code, state, city
FROM staging_loans
WHERE region_code IS NOT NULL
ON CONFLICT (region_id) DO NOTHING;

INSERT INTO dim_borrower(borrower_id, age, gender, income)
SELECT DISTINCT borrower_id, borrower_age, borrower_gender, borrower_income
FROM staging_loans s
WHERE s.borrower_id IS NOT NULL
ON CONFLICT (borrower_id) DO UPDATE
  SET age = EXCLUDED.age,
      gender = EXCLUDED.gender,
      income = COALESCE(EXCLUDED.income, dim_borrower.income);

INSERT INTO dim_loan_grade(grade_id, grade_desc)
SELECT DISTINCT loan_grade, loan_grade
FROM staging_loans
WHERE loan_grade IS NOT NULL
ON CONFLICT (grade_id) DO NOTHING;

INSERT INTO fact_loan_performance (
    loan_id, borrower_id, region_id, time_id, disbursement_date, origination_date,
    loan_amount, outstanding_amount, term_months, product, grade_id, status,
    delinquency_days, charge_off_flag, default_date
)
SELECT
    s.loan_id,
    s.borrower_id,
    s.region_code,
    s.origination_date,
    s.disbursement_date,
    s.origination_date,
    COALESCE(s.loan_amount,0)::numeric(14,2),
    COALESCE(s.outstanding_amount,0)::numeric(14,2),
    COALESCE(s.term_months,0)::int,
    s.product,
    s.loan_grade,
    s.status,
    COALESCE(s.delinquency_days,0)::int,
    COALESCE(s.charge_off_flag,0)::int,
    s.default_date
FROM staging_loans s
WHERE NOT EXISTS (
    SELECT 1 FROM fact_loan_performance f WHERE f.loan_id = s.loan_id
);

CREATE INDEX IF NOT EXISTS idx_fact_loan_borrower_id ON fact_loan_performance (borrower_id);
CREATE INDEX IF NOT EXISTS idx_fact_loan_origdate ON fact_loan_performance (origination_date);
CREATE INDEX IF NOT EXISTS idx_fact_region_grade ON fact_loan_performance (region_id, grade_id);

CREATE MATERIALIZED VIEW IF NOT EXISTS mv_delinquency_rollup
AS
SELECT
    COALESCE(r.region_name, 'ALL') AS region_name,
    COALESCE(g.grade_desc, 'ALL') AS grade_desc,
    date_trunc('month', f.origination_date)::date AS month,
    COUNT(*) AS total_loans,
    SUM(CASE WHEN f.status ILIKE 'delinquent' OR f.delinquency_days > 0 THEN 1 ELSE 0 END) AS delinquent_loans,
    SUM(CASE WHEN f.charge_off_flag = 1 THEN 1 ELSE 0 END) AS charge_offs,
    ROUND(100.0 * SUM(CASE WHEN f.charge_off_flag = 1 THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0),2) AS charge_off_pct
FROM fact_loan_performance f
LEFT JOIN dim_region r ON f.region_id = r.region_id
LEFT JOIN dim_loan_grade g ON f.grade_id = g.grade_id
GROUP BY ROLLUP (r.region_name, g.grade_desc, date_trunc('month', f.origination_date)::date);

CREATE INDEX IF NOT EXISTS idx_mv_delinquency_month ON mv_delinquency_rollup (month);
CREATE INDEX IF NOT EXISTS idx_mv_delinquency_region ON mv_delinquency_rollup (region_name);

CREATE MATERIALIZED VIEW IF NOT EXISTS mv_portfolio_kpis
AS
SELECT
    date_trunc('month', time_id)::date AS month,
    COUNT(*) AS loans_count,
    SUM(loan_amount) AS total_orig_amount,
    SUM(outstanding_amount) AS total_outstanding,
    SUM(CASE WHEN charge_off_flag = 1 THEN outstanding_amount ELSE 0 END) AS total_charge_off_amount,
    ROUND(100.0 * SUM(CASE WHEN charge_off_flag = 1 THEN outstanding_amount ELSE 0 END) / NULLIF(SUM(outstanding_amount),0), 2) AS charge_off_rate_pct
FROM fact_loan_performance
GROUP BY date_trunc('month', time_id);

CREATE INDEX IF NOT EXISTS idx_mv_kpis_month ON mv_portfolio_kpis (month);

SELECT 'missing_loan_ids' AS check, COUNT(*) FROM staging_loans WHERE loan_id IS NULL;
SELECT 'missing_borrower_ids' AS check, COUNT(*) FROM staging_loans WHERE borrower_id IS NULL;

SELECT loan_id, loan_amount FROM staging_loans WHERE loan_amount < 0 LIMIT 20;
SELECT loan_id, delinquency_days FROM staging_loans WHERE delinquency_days > 3650 LIMIT 20;

SELECT * FROM mv_portfolio_kpis
WHERE month BETWEEN date_trunc('month', CURRENT_DATE - INTERVAL '12 months') 
                AND date_trunc('month', CURRENT_DATE)
ORDER BY month DESC;

WITH cohorts AS (
    SELECT
        date_part('year', origination_date)::int AS cohort_year,
        loan_id,
        CASE WHEN status ILIKE 'default' OR charge_off_flag = 1 THEN 1 ELSE 0 END AS is_default,
        row_number() OVER (PARTITION BY date_part('year', origination_date)::int ORDER BY origination_date) AS rn
    FROM fact_loan_performance
)
SELECT cohort_year,
       COUNT(loan_id) AS loans_in_cohort,
       SUM(is_default) AS defaults,
       ROUND(100.0 * SUM(is_default) / NULLIF(COUNT(loan_id),0),2) AS default_rate_pct
FROM cohorts
GROUP BY cohort_year
ORDER BY cohort_year;

SELECT region_name, grade_desc, month,
       total_loans, delinquent_loans, charge_offs, charge_off_pct
FROM mv_delinquency_rollup
WHERE month >= date_trunc('month', CURRENT_DATE - INTERVAL '6 months')
ORDER BY region_name NULLS FIRST, grade_desc NULLS FIRST, month DESC
LIMIT 1000;

WITH borrower_stats AS (
    SELECT borrower_id,
           COUNT(*) AS loans_count,
           SUM(loan_amount) AS total_orig_amount,
           SUM(outstanding_amount) AS total_outstanding,
           SUM(CASE WHEN charge_off_flag = 1 THEN 1 ELSE 0 END) AS charge_offs,
           SUM(CASE WHEN (status ILIKE 'delinquent' OR delinquency_days > 0) THEN 1 ELSE 0 END) AS delinq_count
    FROM fact_loan_performance
    GROUP BY borrower_id
)
SELECT borrower_id, loans_count, total_orig_amount, total_outstanding, charge_offs, delinq_count
FROM borrower_stats
ORDER BY charge_offs DESC, delinq_count DESC
LIMIT 100;

WITH loan_events AS (
    SELECT
        loan_id,
        origination_date,
        COALESCE(default_date, CURRENT_DATE) AS end_date,
        greatest(0, date_part('month', age(COALESCE(default_date, CURRENT_DATE), origination_date)))::int AS months_to_event,
        CASE WHEN charge_off_flag = 1 THEN 1 ELSE 0 END AS event_default
    FROM fact_loan_performance
)
SELECT months_to_event,
       COUNT(loan_id) AS loans_at_month,
       SUM(event_default) AS defaults_at_month,
       ROUND(100.0 * SUM(event_default) / NULLIF(COUNT(loan_id),0),2) AS default_rate_pct
FROM loan_events
GROUP BY months_to_event
ORDER BY months_to_event
LIMIT 60;

SELECT
    region_id, grade_id, date_trunc('year', origination_date)::int AS year,
    COUNT(*) AS total_loans,
    SUM(CASE WHEN charge_off_flag = 1 THEN 1 ELSE 0 END) AS charge_offs
FROM fact_loan_performance
GROUP BY CUBE (region_id, grade_id, date_trunc('year', origination_date)::int)
ORDER BY region_id NULLS FIRST, grade_id NULLS FIRST, year NULLS FIRST
LIMIT 200;
